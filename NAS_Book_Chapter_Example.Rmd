---
title: "第三层议程设置"
author: "Chris Chao Su, Lei Guo, Hsuan-Ting Chen"
date: "1/22/2021"
output:
  word_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## 第三层议程设置的数据建立和假设检验。

此处的实例操作以Chen, Guo & Su (2020)发表于 Journal of Communication的文章为例，来说明如何使用媒体和个人问卷数据，利用R来建立议程之间的关系矩阵，然后使用二次指派回归程序（MRQAP）来分析矩阵之间的关系，从而回答第三层议程设置的研究假设。

在此过程中，我们使用了多个R包，用于数据处理、建立矩阵、计算回归程序的统计显著性等。

```{r load-packages, include=FALSE}
library(haven) #用于读取sav数据
library(readxl) #用户读取Excel数据
library(dplyr) #用于数据处理
library(tidyverse) #用于数据处理
library(magrittr) #用于数据处理
library(gdata) # 用于矩阵的数据处理
library(dils) # 将属性关系转换为矩阵
library(asnipe) #用于MRQAP分析
library(igraph) #可视化
library(sna) #用于简单可视化，也可用于MRQAP分析
```

### 步骤一：数据读取

接下来我们要看看研究中主要使用的两种不同类型的数据。

第一种数据是媒体数据，涵盖了香港的主要新闻媒体机构，根据媒体的政治倾向不一，可以大致划分为三类：建制派新闻媒体、泛民派新闻媒体、以及中立的新闻媒体。在获取了每一条新闻数据之后，我们接着对每一条新闻内容进行编码，如果该条新闻所报道的内容有涉及到某一个具体的议题，那么我们就以数字“1”记录，没有涉及到的议题则不做记录。

利用SPSS，我们可以进一步将数据转换成在R中更为方便的类型，也就是说，将没有涉及到的议题全部以数字“0”记录，以方便接下来我们运算属性网络矩阵。

编码后的新闻数据我们在SPSS中预处理后，以sav的各式储存，并读入到R中，这里我们直接使用预处理好的新闻媒介数据“media_final.sav”。对每一条新闻数据，我们有以下编码：新闻媒体机构（Q2），媒体的政治倾向（Media_party），每一条新闻内容的独特编号（Q3），以及十六个议题的编码结果（Issue1 ~ Issue16）。在Media_party这一变量中，1 = “泛民派新闻媒体”，2 = “中立新闻媒体”，3 = “建制派新闻媒体”。

```{r}
Media_final <- haven::read_sav("Media_final.sav")
Media_final <- Media_final[c(2,4,5,69:84)]
head(Media_final)
```

第二类数据是代表公众想法的关联网络矩阵（认知属性网络）。在此研究中，我们使用的是以问卷调查方式收集到的数据。同样地，经过SPSS预处理之后，我们可以得到一个sav格式的数据。
这一数据包含有一下信息：
* respid： 每一位有效受访者的ID
* partisan： 受访者的政治倾向（“1” = 泛民派支持者，“2” = 政治中立者， “3” = 建制派支持者）
* self_1_R ~ self_5_R: 受访者关注的五个议题，每一个议题在数据中由1～16的代号标记（共16个议题）
* q12_1 ~ q21_1: 受访者认为每对议题之间的关系强度，如受访者未提及某一项议题，则与此议题相关的关系皆为缺省值NA；若受访者认为两者之间无关联，则值为“999

同样地，我们可以将数据读入到R中：

```{r}
survey_all <- haven::read_sav("survey_all.sav")
survey_all <- survey_all[c(1, 146, 334:338, 264:273)] 
head(survey_all)
```


### 步骤二：媒体关联网络矩阵

首先我们将数据根据新闻媒体的政治立场进行细分。

```{r}
Media_democ <- Media_final[which(Media_final$Media_party==1),] # 泛民派新闻媒体
Media_neutr <- Media_final[which(Media_final$Media_party==2),] # 中立新闻媒体
Media_proes <- Media_final[which(Media_final$Media_party==3),] # 建制派新闻媒体

```

接下来我们就可以针对每一种政治类型的媒介数据来运算其属性网络矩阵。

首先是泛民派新闻媒体，选取其16个议题的编码内容，转换成矩阵格式，计算倒置矩阵，再通过倒置矩阵与原矩阵相乘的方式得到16*16的属性网络矩阵。
```{r}
Media_democ <- Media_democ %>% select(Issue1:Issue16) #选取议题的编码内容
Media_democ <- as.matrix(Media_democ) # 转换为矩阵格式
Media_democ_T <- t(Media_democ) # 计算倒置矩阵
Media_democ_matrix <- Media_democ_T %*% Media_democ # 计算属性网络矩阵
Media_democ_matrix
```

然后为了方便之后的MRQAP程序，我们对矩阵的数据类型和议题/属性的表头进行修正，并且将所以对角线数据（即议题与自己之间的关系）全部设置为0。其中Issue_names_R是一个议题与议题编号之间的对应表格。

```{r}
Media_democ_matrix <- Media_democ_matrix %>% as.matrix
diag(Media_democ_matrix) <- 0

Issue_names_R <- read_excel("Issue_names_R.xlsx")
Issue_names_R # 议题与议题编号之间的对应表格

colnames(Media_democ_matrix) <- Issue_names_R$Issues[1:16] # 对属性网络重新命名
rownames(Media_democ_matrix) <- Issue_names_R$Issues[1:16] # 对属性网络重新命名
```

最后，可以看到属性网络矩阵的最后数据形式和内容：

```{r}
Media_democ_matrix[1:5,1:5] # 在这里我们只展示前五行和前五列的数据
```


接着我们可以以同样的方式计算中立媒体以及建制派新闻媒体16*16的属性网络矩阵。

```{r}
# 中立媒体的议程关系矩阵

Media_neutr <- Media_neutr %>% select(Issue1:Issue16)

Media_neutr <- as.matrix(Media_neutr)
Media_neutr_T <- t(Media_neutr)
Media_neutr_matrix <- Media_neutr_T %*% Media_neutr

Media_neutr_matrix <- Media_neutr_matrix %>% as.matrix
diag(Media_neutr_matrix) <- 0
colnames(Media_neutr_matrix) <- Issue_names_R$Issues[1:16]
rownames(Media_neutr_matrix) <- Issue_names_R$Issues[1:16]

```

```{r}
# 建制派媒体的议程关系矩阵

Media_proes <- Media_proes %>% select(Issue1:Issue16)

Media_proes <- as.matrix(Media_proes)
Media_proes_T <- t(Media_proes)
Media_proes_matrix <- Media_proes_T %*% Media_proes

Media_proes_matrix <- Media_proes_matrix %>% as.matrix
diag(Media_proes_matrix) <- 0

colnames(Media_proes_matrix) <- Issue_names_R$Issues[1:16]
rownames(Media_proes_matrix) <- Issue_names_R$Issues[1:16]

```

### 步骤三：公众关联网络矩阵（认知属性网络）

公众关联网络矩阵的建立则与媒体矩阵稍有不同，主要差别在于，我们需要考虑到每个受访者所回答的议题关联强度。因此，我们需要首先对所有可能的出现的议题建立对应关系，然后与问卷中与每一对议题的关联强度进行一一映射，最后还要将每一对议题之间（pairs of every two given issues) 的总关系强度进行整合。

同样地，我们将公众问卷数据根据受访者的政治倾向进行细分，并为每一种政治倾向的受访者群体建立新的子数据：

```{r}
Democratic <-survey_all[ which (survey_all$partisan==1),] # 泛民派支持者
Centrists <-survey_all[ which (survey_all$partisan==2),] # 政治中立者
Establish <-survey_all[ which (survey_all$partisan==3),] # 建制派支持者
```

以泛民支持者的认知属性网络为例。我们首先需要选取五个属性变量（self_1_R ～ self_5_R）以及十个属性间关系变量（q12_1 ～ q12_1），并对缺省值和无关联值（999）进预处理。

```{r}
# 选取属性变量
D_self_issues <- Democratic %>% select(respid, self_1_R,self_2_R, self_3_R, self_4_R, self_5_R)
D_self_issues[is.na(D_self_issues)] <- 0 

# 选取属性关系变量
D_self_weights <- Democratic %>% select(respid, q12_1:q21_1)
D_self_weights[D_self_weights == 999] <- 0
D_self_weights[is.na(D_self_weights)] <- 0
```

然后对数据中的每一对属性（a pair of issues）建立一种关系结构，并按照属性标号进行排序。

```{r}
# 建立每一对属性之间的关系结构
D_self = data.frame()
for (i in 1: length(dimnames(D_self_issues)[[1]])) {
  v = unlist(D_self_issues[i, 2:6]) 
  v = t(combn(v,2))
  D_self = rbind(D_self, v)
} 
D_self <- t(apply(D_self,1,sort)) %>% as.data.frame() # 在这里，属性之间的关系是无方向的
```

将属性之间的关系强度值映射到上叙属性关系结构中

```{r}
# 增加属性之间的关系强度值（weights）
D_self_w = c()
for (i in 1: length(dimnames(D_self_weights)[[1]])) {
  w = unlist(D_self_weights[i, 2:11])
  w = t(combn(w,1))
  D_self_w = append(D_self_w,w)
}
D_self$weight <- D_self_w

D_self <- D_self[!D_self$V1 %in% c(0), ] # 移除所有的无关系属性对
D_self <- aggregate(weight~V1+V2, data = D_self, FUN = sum) # 整合同属性对之间的关系强度 
```

建立认知属性矩阵：

```{r}
D_self_matrix <- AdjacencyFromEdgelist(D_self, check.full = TRUE) %>% as.data.frame()
D_self_matrix <- D_self_matrix[1:16, 1:16]
D_self_matrix
```

对认知属性矩阵进行重命名和调整：
```{r}
colnames(D_self_matrix) <- Issue_names_R$Issues
rownames(D_self_matrix) <- Issue_names_R$Issues

D_self_matrix <- D_self_matrix %>% as.matrix
diag(D_self_matrix) <- 0 # 去除属性自身之间的强度值
lowerTriangle(D_self_matrix) <- upperTriangle(D_self_matrix, byrow = TRUE) #生成整体矩阵

head(D_self_matrix)
```

以相同的方式，我们可以建立建制派支持者的认知属性网络：

```{r}
# 选取属性变量
E_self_issues <- Establish %>% select(respid, self_1_R,self_2_R, self_3_R, self_4_R, self_5_R)
E_self_issues[is.na(E_self_issues)] <- 0

# 选取属性关系变量
E_self_weights <- Establish %>% select(respid, q12_1:q21_1)
E_self_weights[E_self_weights == 999] <- 0
E_self_weights[is.na(E_self_weights)] <- 0

# 建立每一对属性之间的关系结构
E_self = data.frame()
for (i in 1: length(dimnames(E_self_issues)[[1]])) {
  v = unlist(E_self_issues[i, 2:6]) 
  v = t(combn(v,2))
  E_self = rbind(E_self, v)
} 
E_self <- t(apply(E_self,1,sort)) %>% as.data.frame() 

# 增加属性之间的关系强度值（weights）
E_self_w = c()
for (i in 1: length(dimnames(E_self_weights)[[1]])) {
  w = unlist(E_self_weights[i, 2:11])
  w = t(combn(w,1))
  E_self_w = append(E_self_w,w)
}
E_self$weight <- E_self_w

E_self <- E_self[!E_self$V1 %in% c(0), ] 
E_self <- aggregate(weight~V1+V2, data = E_self, FUN = sum)

# 建立认知属性矩阵
E_self_matrix <- AdjacencyFromEdgelist(E_self, check.full = TRUE) %>% as.data.frame()
E_self_matrix <- E_self_matrix[1:16, 1:16]

# 对认知属性矩阵进行重命名和调整
colnames(E_self_matrix) <- Issue_names_R$Issues
rownames(E_self_matrix) <- Issue_names_R$Issues
# Adjusting final matrix
E_self_matrix <- E_self_matrix %>% as.matrix
diag(E_self_matrix) <- 0
lowerTriangle(E_self_matrix) <- upperTriangle(E_self_matrix, byrow = TRUE)

```

### 步骤四：研究假设验证（MRQAP）

在此，我们使用MRQAP对新闻媒体的属性网络和公众的认知属性网络之关联性进行分析，并验证以下两个研究假设：
* 假设一：香港建制派新闻媒体的属性网络和建制派支持者的认知属性网络存在显著关联。
* 假设二：香港泛民派新闻媒体的属性网络和泛民派支持者的认知属性网络存在显著关联。

在这里我们使用的R包是“asnipe”，实际上也可以使用sna包中的netlm函数

验证假设一：
```{r}
proesfit <- mrqap.dsp(E_self_matrix ~ Media_proes_matrix + Media_democ_matrix + Media_neutr_matrix, intercept = TRUE, directed = "undirected", diagonal = FALSE, test.statistic = "t-value", tol = 1e-07, randomisations = 1000)

proesfit
```

验证假设二：
```{r}
democfit <- mrqap.dsp(D_self_matrix ~ Media_proes_matrix + Media_democ_matrix + Media_neutr_matrix, intercept = TRUE, directed = "undirected",  diagonal = FALSE, test.statistic = "t-value", tol = 1e-07, randomisations = 1000)

democfit
```

### 步骤五：可视化

这里我们用建制派媒体的关系可视化为例（此处使用R包igraph，也可以使用sna包进行可视化）：
```{r}
plot <- graph_from_adjacency_matrix(Media_proes_matrix, mode = c("undirected"), weighted = TRUE, diag = FALSE,add.rownames = TRUE)
plot.igraph(plot,vertex.label=V(plot)$name,layout=layout.fruchterman.reingold,edge.color="black",edge.width=E(plot)$weight*.05)
```


